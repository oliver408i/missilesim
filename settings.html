<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Difficulty settings</title>
    <style>
        label {
            font-weight: bold;
            color: white;
        }
        p {
            color: white;
            font-size: 14px;
        }
        h3 {
            color: white;
        }
        
        /* Hide scrollbar for Chrome, Safari and Opera */
        ::-webkit-scrollbar {
            width: 5px;
        }
        
        /* Track */
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        /* Handle */
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
        }
        
        /* Handle on hover */
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 1);
        }
        
        /* Handle on set */
        ::-webkit-scrollbar-thumb:active {
            background: rgba(255, 255, 255, 0.8);
        }
        
        /* Handle on set */
        ::-webkit-scrollbar-thumb:window-inactive {
            background: rgba(255, 255, 255, 0.4);
        }

        .modification-label {
            font-weight: normal;
            font-size: 14px;
            color: white;
        }

        .tooltip {
            display: none;
            position: fixed;
            z-index: 9999;
            max-width: calc(100vw - 20px);
            width: 200px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 5px;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .tooltip p{
            font-size: 12px;
        }
        
    </style>
</head>
<body>
    <form id="dropdownForm">

        <div id="modSettings"></div>

        <h3>Missile Settings</h3>
        <!--<label for="irccm">IRCCM</label>
        <p>IRCCM mode. Outliner draws wireframes around flares of a certain temperature or higher. Radar will get information from the aircraft radar regarding where the target is. Note that the radar works best when the missile is directly pointing at the target.</p>
        <select id="irccm" name="irccm">
            <option value="None">None</option>
            <option value="outliner">Flare Outliner</option>
            <option value="radar">Radar</option>
        </select>
        <br><br>-->
        
        <!--<label for="proxyFuse">Proxy Fuse</label>
        <p>Proxy fuse will automatically detonate the missile once it gets in a certain distance of a certain object. Auto targetting will only target the actual object. Rangefinder mode will detonate the missile when the rangefinder encounters any close object. Rangefinder mode only works if the rangefinder is in front-linear mode</p>
        <select id="proxyFuse" name="proxyFuse">
            <option value="None">Off</option>
            <option value="autoTargetting">Auto Targetting</option>
            <option value="laser">Rangefinder</option>
        </select>

        <br><br>-->

        <!--<label for="rangefinderMode">Rangefinder Mode</label>
        <p>The laser rangefinder will display how far away an object is. Linear mode looks for the closest object directly in front of the missile. Omnidirectional finds the closest object in all directions.</p>
        <select id="rangefinderMode" name="rangefinderMode">
            <option value="None">Off</option>
            <option value="linear">Front-Linear</option>
            <option value="omni">Omnidirectional</option>
        </select>

        <br><br>-->

        
        <label for="proxyFuseDistance">Proxy Fuse Distance</label>
        <p>Distance in meters at which the missile will automatically detonate. Affects all proxy fuse modes.</p>
        <input type="number" id="proxyFuseDistance" name="proxyFuseDistance" min="1" max="20" value="5"/>
        <br><br>

        <label for="sight">Sight</label>
        <p>Which sight to use</p>
        <select id="sight" name="sight">
            <option value="sight">Default Full Sight</option>
            <option value="cleansight">Minimal Sight</option>
            <option value="crosshair">Crosshair Only</option>
        </select>

        <br><br>

        <h3>Difficulty Settings</h3>
        <label for="targetDistance">Target Distance</label>
        <p>How far away should the target spawn.</p>
        <input type="number" id="targetDistance" name="targetDistance" min="100" max="500" value="500"/>
        
        <br><br>

        <label for="distanceThreshold">Distance Threshold</label>
        <p>How close the missile needs to be to the target when it explodes to count as a hit.</p>
        <input type="number" id="distanceThreshold" name="distanceThreshold" min="1" max="20" value="10"/>

        <br><br>

        <label for="missThreshold">Miss Time Threshold</label>
        <p>How long in seconds the target can be out of the missile's FOV until it is considered missed.</p>
        <input type="number" id="missThreshold" name="missThreshold" min="0" max="5" value="2"/>

        <br><br>

        <label for="flareChance">Flare Chance</label>
        <p>Chance for a flare burst to be deployed every tick. 1.0 = 100% chance, max is 10%</p>
        <input type="number" id="flareChance" name="flareChance" min="0" max="0.1" value="0.02"/>

        <br><br>

        <label for="flareCount">Flare Max Count</label>
        <p>How many flares (at max) can be deployed by the target.</p>
        <input type="number" id="flareCount" name="flareCount" min="1" max="20" value="10"/>

        <br><br>

        <h3>Misc Settings</h3>

        <label for="showFPS">Show FPS</label>
        <p>Show FPS in game</p>
        <select id="showFPS" name="showFPS">
            <option value="None">Off</option>
            <option value="0">FPS</option>
            <option value="1">ms</option>
            <option value="2">MB</option>
        </select>

        <br><br>

        <label for="realisticControls">Realistic Controls</label>
        <p>Use realistic controls. W and S are pitch, A and D are yaw, Q and E are roll.</p>
        <select id="realisticControls" name="realisticControls">
            <option value="0">Simple (off)</option>
            <option value="1">Semi (pitch not inverted)</option>
            <option value="2">Full</option>
        </select>
    
    </form>

    <script>
        // Load modifications json from assets/modifications.json
        let modifications = fetch('assets/modifications.json').then(response => response.json()).then(data => modifications = data);
        
        modifications.then(data => {
            const modificationsDiv = document.createElement('div');
            modificationsDiv.id = 'modificationsDiv';
            modificationsDiv.className = 'settings-container';
            modificationsDiv.innerHTML = '<h3>Modifications</h3>';

            const grid = document.createElement('div');
            grid.className = 'grid-container';

            for (let modification of data) {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = modification.name;

                const label = document.createElement('label');
                label.className = 'modification-label';
                label.appendChild(document.createTextNode(modification.name));
                
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.innerText = modification.description;
                document.body.appendChild(tooltip);

                const category = document.createElement('p');
                category.innerText = 'Category: ' + modification.category;
                tooltip.appendChild(category);

                const modifyMethod = document.createElement('p');
                modifyMethod.innerText = 'Modify Method: ' + modification.modifyMethod;
                tooltip.appendChild(modifyMethod);

                const modifies = document.createElement('p');
                modifies.innerText = 'Modifies: ' + JSON.stringify(modification.modifies);
                tooltip.appendChild(modifies);

                if (modification.incompatible) {
                    const incompatible = document.createElement('p');
                    incompatible.innerText = 'Incompatible: ' + JSON.stringify(modification.incompatible);
                    tooltip.appendChild(incompatible);
                }

                if (modification.requires) {
                    const requires = document.createElement('p');
                    requires.innerText = 'Requires: ' + JSON.stringify(modification.requires);
                    tooltip.appendChild(requires);
                }
                
                
                label.addEventListener('mouseover', (event) => {
                    tooltip.style.display = 'block';
                    tooltip.style.top = event.pageY + 'px';
                    tooltip.style.left = event.pageX + 'px';
                });

                label.addEventListener('mouseout', () => {
                    tooltip.style.display = 'none';
                });

                const gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                gridItem.appendChild(checkbox);
                gridItem.appendChild(label);
                grid.appendChild(gridItem);
            }

            modificationsDiv.appendChild(grid);
            document.getElementById('modSettings').appendChild(modificationsDiv);
        });

        // Load old settings if they exist
        if (localStorage.getItem('missileSpecs')) {
            const data = JSON.parse(localStorage.getItem('missileSpecs'));
            const difficultyData = JSON.parse(localStorage.getItem('difficultyData'));
            const miscSettings = JSON.parse(localStorage.getItem('miscSettings'));

            document.getElementById('proxyFuseDistance').value = data.proxyFuseDistance;
            document.getElementById('sight').value = data.sightImage;

            document.getElementById('targetDistance').value = difficultyData.targetDistance;
            document.getElementById('distanceThreshold').value = difficultyData.distanceThreshold;
            document.getElementById('flareChance').value = difficultyData.flareChance;
            document.getElementById('flareCount').value = difficultyData.flareCount;
            document.getElementById('missThreshold').value = difficultyData.missThreshold;

            document.getElementById('showFPS').value = localStorage.getItem('showFPS');

            document.getElementById('realisticControls').value = miscSettings.controlMode;


        }

        document.getElementById('showFPS').addEventListener('change', function() {
            localStorage.setItem('showFPS', this.value);
            window.parent.postMessage("grabNewShowFPSSetting");
        })

        function saveToLocalStorage() {
            // Validate inputs
            const inputs = [
                document.getElementById('proxyFuseDistance'),
                document.getElementById('sight'),
                document.getElementById('targetDistance'),
                document.getElementById('distanceThreshold'),
                document.getElementById('flareChance'),
                document.getElementById('flareCount'),
                document.getElementById('missThreshold')
            ];

            inputs.forEach(input => {
                if (parseInt(input.value) < parseInt(input.min) || parseInt(input.value) > parseInt(input.max)) {
                    alert(`Invalid input: ${input.id}! Clamping to ${input.min} - ${input.max}`);
                    console.log(input.value);
                    input.value = Math.max(input.min, input.value);
                    input.value = Math.min(input.max, input.value);
                }
            });

            console.log("Saving settings");
            const proxyFuseDistance = document.getElementById('proxyFuseDistance').value;
            const sight = document.getElementById('sight').value;

            const difficultyData = {
                targetDistance: document.getElementById('targetDistance').value,
                distanceThreshold: document.getElementById('distanceThreshold').value,
                flareChance: document.getElementById('flareChance').value,
                flareCount: document.getElementById('flareCount').value,
                missThreshold: document.getElementById('missThreshold').value
            };
            localStorage.setItem('difficultyData', JSON.stringify(difficultyData));

            

            const miscSettings = {
                controlMode: document.getElementById('realisticControls').value
            }
            localStorage.setItem('miscSettings', JSON.stringify(miscSettings));

            
            const modSelections = document.getElementById('modSettings').getElementsByTagName('input');
            const enabledModifications = [];
            for (const modSelection of modSelections) {
                if (modSelection.checked) {
                    const modData = modifications.find(mod => mod.name === modSelection.name);
                    if (modData) {
                        const incompatibleMods = modData.incompatible || [];
                        const enabledIncompatibleMods = enabledModifications.filter(mod => incompatibleMods.includes(mod.name));
                        if (enabledIncompatibleMods.length > 0) {
                            alert(`Modification ${modSelection.name} is incompatible with ${enabledIncompatibleMods.map(mod => mod.name).join(', ')}. Please disable them before enabling this modification.`);
                            return;
                        }
                        
                        const requiredMods = modData.requires || [];
                        const enabledRequiredMods = enabledModifications.filter(mod => requiredMods.includes(mod.name));
                        if (enabledRequiredMods.length != requiredMods.length) {
                            alert(`Modification ${modSelection.name} requires ${requiredMods.join(', ')} to be enabled. Please enable them before enabling this modification.`);
                            return;
                        }
                        enabledModifications.push(modData);
                    } else {
                        alert(`Modification ${modSelection.name} not found!`);
                        return;
                    }
                }
            }
            localStorage.setItem('enabledModifications', JSON.stringify(enabledModifications));
            
            let irccm = "None";
            let proxyFuse = "None";
            let rangefinderMode = "None";

            console.log(enabledModifications);

            for (const mod of enabledModifications) {
                if (mod.modifies.irccmMode) {
                    irccm = mod.modifies.irccmMode;
                } else if (mod.modifies.proxyFuse) {
                    proxyFuse = mod.modifies.proxyFuse;
                } else if (mod.modifies.rangefinderMode) {
                    rangefinderMode = mod.modifies.rangefinderMode;
                }
            }

            const data = {
                irccmMode: irccm,
                proxyFuse: proxyFuse,
                proxyFuseDistance: proxyFuseDistance,
                rangefinderMode: rangefinderMode,
                sightImage: sight

            };
            localStorage.setItem('missileSpecs', JSON.stringify(data));
            
            
            

            window.parent.postMessage("startGame");
        }
    </script>
</body>
</html>